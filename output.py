# Form implementation generated from reading ui file 'Billing.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
import calendar
import itertools
import os
import re
import sys
import time
from collections import Counter

import numpy as np
import openpyxl
import pandas as pd
import xlsxwriter
from dateutil.parser import parse
from openpyxl import load_workbook
from openpyxl.styles import Alignment, Border, Font, PatternFill, Side
from openpyxl.worksheet.merge import MergeCell, MergeCells
from pandas._libs.tslibs.timestamps import Timestamp
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import QDate, Qt
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import (
    QApplication,
    QFileDialog,
    QLabel,  # type: ignore
    QMainWindow,
    QMessageBox,
    QPushButton,
)
from openpyxl.utils import quote_sheetname


HOLIDAY_LIST_2024 = [
    "01-01-2024",
    "15-01-2024",
    "26-01-2024",
    "25-03-2024",
    "29-03-2024",
    "09-04-2024",
    "11-04-2024",
    "01-05-2024",
    "13-05-2024",
    "15-08-2024",
    "02-10-2024",
    "31-10-2024",
    "25-12-2024",
]


TOTAL_WORKING_DAY = 0


def read_file(file_path):
    try:
        # Check file extension to determine how to read the file
        if file_path.endswith(".csv"):
            df = pd.read_csv(file_path)
        elif file_path.endswith(".xlsx"):
            df = pd.read_excel(file_path)
        else:
            raise ValueError(
                "Unsupported file format. Please provide a CSV or Excel file."
            )

        # Return the DataFrame if reading is successful
        return df.to_dict("records")

    except FileNotFoundError:
        print(f"Error: File not found at '{file_path}'")
    except Exception as e:
        print(f"Error reading file '{file_path}': {e}")

    # Return None if there is an error
    return None


def get_month_details(month_name, year):
    # Get the month number from the month name
    month_number = list(calendar.month_name).index(month_name.capitalize())

    # Get the calendar for the specified month and year
    cal = calendar.monthcalendar(year, month_number)

    # Dictionary to map weekday number to weekday name
    weekdays = {
        0: "Monday",
        1: "Tuesday",
        2: "Wednesday",
        3: "Thursday",
        4: "Friday",
        5: "Saturday",
        6: "Sunday",
    }

    month_details = []

    # Iterate through each week in the month
    for week in cal:
        week_details = []
        # Iterate through each day in the week
        for day in week:
            # If the day is zero, it means it's part of the previous or next month
            if day == 0:
                week_details.append(None)
            else:
                # Get the day name using the weekdays dictionary
                day_name = weekdays[calendar.weekday(year, month_number, day)]
                # Check if it's a weekend (Saturday or Sunday)
                is_weekend = day_name in ["Saturday", "Sunday"]
                # Append the day details to the week_details list
                week_details.append(
                    {"day": day, "day_name": day_name, "is_weekend": is_weekend}
                )
        # Append the week_details list to the month_details list
        month_details.append(week_details)

    return month_details, month_number


# add validation of month, like if use data is for april and month is may
# :: TODO calculation for individual user - billable days - fixed
# :: TODO exclude date cal for holiday days if user has marked the attendance
def generate_excel(
    month, year, output_file_name, selected_row, holiday_list, name_mapping
):
    global TOTAL_WORKING_DAY
    sheets_name = []
    try:
        user_data = list()
        month_name = month
        holiday_list = holiday_list

        year = int(year)
        month_details, month_number = get_month_details(month_name, year)
        month_number = f"{month_number:02}" if month_number < 10 else month_number
        month_holiday_list = [
            x for x in holiday_list if re.findall(f"\d+-{month_number}-\d+", x)
        ]
        # print("month_holiday_list ===>", month_holiday_list)
        month_day_holiday_list = [k.split("-")[0] for k in month_holiday_list]
        # print("month_day_holiday_list ===>", month_day_holiday_list)
        df_sheets = dict()
        excel_file_path = output_file_name
        non_complaince_user = []
        for new_data in selected_row:
            billable_days = 0
            weekends = 0
            total_working_days = 0
            data_model = []
            leave_taken = 0
            public_holiday = 0
            mismatch_date = []
            name = preprocess_name(new_data.get("Rsname"))
            for week in month_details:
                for day in week:
                    if day:
                        date = day["day"]
                        is_weekend_or_leave = "Weekend" if day["is_weekend"] else ""
                        if day["is_weekend"]:
                            weekends += 1
                        else:
                            total_working_days += 1
                        dt = f"{date}-{month_name[:3]}"
                        day_name = f"{day['day_name']}"

                        key = (
                            f"{day_name[:3]}, {f'{date:02}' if date < 10 else date}-"
                            f"{month_name[:3].title()}"
                        )
                        # print("DAY ===>", f"{date:02}" if date < 10 else date)
                        # holiday_list = [j.split("-")[0] for j in holiday_list ]
                        calculated_date = f"{date:02}" if date < 10 else f"{date}"
                        if day["is_weekend"]:
                            dt_status = 0
                        else:
                            rounded_values = list(
                                np.around(np.arange(2.5, 4, 0.1), decimals=1)
                            )

                            match new_data.get(key):
                                case 8:
                                    dt_status = 1
                                    # As some user can mark attendace on holiday date
                                    if calculated_date in month_day_holiday_list:
                                        mismatch_date.append(calculated_date)
                                        public_holiday += 1
                                        dt_status = 0

                                        # for Holiday keyword to be added
                                        is_weekend_or_leave = "Holiday"
                                case 4:
                                    dt_status = 0.5
                                    leave_taken += 0.5
                                case value if value in rounded_values:
                                    dt_status = 0.25
                                    leave_taken += 0.25
                                case 0:
                                    if calculated_date in month_day_holiday_list:
                                        public_holiday += 1
                                        dt_status = 0

                                        # for Holiday keyword to be added
                                        is_weekend_or_leave = "Holiday"
                                    else:
                                        leave_taken += 1
                                        dt_status = 0

                                        # for leave keyword to be added
                                        is_weekend_or_leave = "Leave"
                                case _:
                                    leave_taken += 1
                                    dt_status = 0
                        billable_days += dt_status

                        """
                            (dt, day_name[:3], dt_status, is_weekend_or_leave, "", "", "", "")
                            ('1-Jun', 'Thu', 1, '', '', '', '', '')
                        """
                        data_model.append(
                            (
                                dt,
                                day_name[:3],
                                dt_status,
                                is_weekend_or_leave,
                                "",
                                "",
                                "",
                                "",
                            )
                        )

            billable_days = total_working_days - leave_taken
            print("USER =====>", new_data.get("Rsname"))
            print("BILLABLE ====>", billable_days)
            print("WEEKENDS ====>", weekends)
            print("TOTAL WORKING DAYS ====>", total_working_days)
            print("LEAVE TAKEN ====>", leave_taken)
            print("PUBLIC HOLIDAY ====>", public_holiday)
            point_of_contact = (
                name_mapping[name][1] if name_mapping.get(name) else "xxxxxxx"
            )
            ID_521 = name_mapping[name][0] if name_mapping.get(name) else "xxxxxxx"
            if mismatch_date:
                non_complaince_user.append(
                    {
                        "Name": new_data.get("Rsname"),
                        "Month": month,
                        "Listed Month Holiday": month_day_holiday_list,
                        "Attendance Marked on Holiday": mismatch_date,
                    }
                )
            data = {
                "Vendor Organization": ["Resource Name", "Month", "Date"],
                "Hitachi Vantara": [
                    f"{new_data.get('Rsname')}",
                    f"{month_name}",
                    "Day",
                ],
                "Point of Contact": ["5-2-1", "Working Days", "Working Status"],
                f"{point_of_contact}": [
                    f"{ID_521}",
                    f"{total_working_days}",
                    "Remarks",
                ],
                "Adjustments from Last Month": ["", "", ""],
                "0": ["", "", ""],
                "": ["", "", ""],
                "Week Off": ["Personal/Sick Leave", "", ""],
            }
            df = pd.DataFrame(data)

            # Create a new sheet or get the existing one
            sheet_name = new_data.get("Rsname")

            for i in data_model:
                df.loc[len(df)] = i

            df.loc[len(df)] = [
                "Leaves Taken",
                f"{leave_taken}",
                "Billable Days",
                f"{billable_days}",
                "",
                "",
                "",
                "",
            ]

            df.loc[len(df)] = ["Weekends", f"{weekends}", "", "", "", "", "", ""]
            df.loc[len(df)] = [
                "Public Holidays",
                f"{public_holiday}",
                "",
                "",
                "",
                "",
                "",
                "",
            ]

            # print(df)
            df_sheets.update({sheet_name: df})
            user_data.append(
                {
                    "Name": sheet_name,
                    #   "Total Billable Time": (total_working_days-leave_taken-public_holiday) * 8 ,
                    "Billable Time (Hours)": (total_working_days - leave_taken) * 8,
                    #    "Weekends": weekends, "Public Holidays": public_holiday,
                    "Total Number of Billable Days": total_working_days,
                    "Service Credit Pool Days": leave_taken,
                }
            )
        else:
            TOTAL_WORKING_DAY = total_working_days
            print("MISMACTH USER ===>", non_complaince_user)
            # Create a Pandas Excel writer using XlsxWriter as the engine
            with pd.ExcelWriter(excel_file_path, engine="xlsxwriter") as writer:

                for key, value in df_sheets.items():
                    # Write each dataframe to a different sheet
                    value.to_excel(writer, sheet_name=key, index=False)

                # Access the XlsxWriter workbook and worksheet objects
                workbook = writer.book
                worksheets = writer.sheets

                # Access each worksheet and modify the formatting if needed
                for sheet_name, worksheet in worksheets.items():
                    # Example: set column width of the first column to 20
                    worksheet.set_column(0, 0, 20)
                    worksheet.set_column(1, 1, 20)
                    worksheet.set_column(2, 2, 20)
                    worksheet.set_column(3, 3, 15)
                    worksheet.set_column(4, 4, 30)
                    worksheet.set_column(7, 7, 17)

                    sheets_name.append(sheet_name)

            wb_style = load_workbook(excel_file_path)
            border = Border(
                left=Side(border_style="thin"),
                right=Side(border_style="thin"),
                top=Side(border_style="thin"),
                bottom=Side(border_style="thin"),
            )
            for i in sheets_name:
                sheet = wb_style[i]

                for row in sheet.iter_rows():
                    for cell in row:
                        cell.border = border
                        if cell.value == "Weekend":
                            numbers = re.findall(r"\d+", cell.coordinate)[0]
                            cell_list = [
                                f"B{numbers}",
                                f"C{numbers}",
                                f"D{numbers}",
                            ]
                            for k in cell_list:
                                cell_bold = sheet[k]
                                cell_bold.fill = PatternFill(
                                    start_color="b6bbbf",
                                    end_color="b6bbbf",
                                    fill_type="solid",
                                )  # grey color
                        if cell.value == "Leave":
                            cell_bold = sheet[cell.coordinate]
                            cell_bold.fill = PatternFill(
                                start_color="fce1dc",
                                end_color="fce1dc",
                                fill_type="solid",
                            )  # red color

                        if cell.value == "Holiday":
                            cell_bold = sheet[cell.coordinate]
                            cell_bold.fill = PatternFill(
                                start_color="cffccf",
                                end_color="cffccf",
                                fill_type="solid",
                            )  # green color

                        if cell.value in [
                            "Leaves Taken",
                            "Weekends",
                            "Public Holidays",
                            "Billable Days",
                        ]:
                            cell_bold = sheet[cell.coordinate]
                            cell_bold.font = Font(bold=True, color="FFFFFF")
                            cell_bold.fill = PatternFill(
                                start_color="4d6c82",
                                end_color="4d6c82",
                                fill_type="solid",
                            )

                for j in ["B1", "D1", "H1", "F1"]:
                    cell_bold = sheet[j]
                    cell_bold.font = Font(bold=False)

                for j in [
                    "A1",
                    "C1",
                    "E1",
                    "A2",
                    "C2",
                    "A3",
                    "C3",
                    "A4",
                    "B4",
                    "C4",
                    "D4",
                    "G1",
                    "G2",
                ]:
                    cell_bold = sheet[j]
                    cell_bold.font = Font(bold=True)
                    if j == "G2":
                        cell_bold.fill = PatternFill(
                            start_color="fce1dc",
                            end_color="fce1dc",
                            fill_type="solid",
                        )  # red color
                    else:
                        cell_bold.fill = PatternFill(
                            start_color="b6bbbf",
                            end_color="b6bbbf",
                            fill_type="solid",
                        )  # grey color

                for j in ["A4", "B4", "C4", "D4", "E4", "F4"]:
                    cell_bold = sheet[j]
                    cell_bold.font = Font(bold=True, color="FFFFFF")
                    cell_bold.fill = PatternFill(
                        start_color="4d6c82", end_color="4d6c82", fill_type="solid"
                    )

                for k in [chr(i) + f"{j}" for i in range(65, 73) for j in range(1, 5)]:
                    cell = sheet[k]
                    cell.alignment = Alignment(horizontal="left")

                for k in [f"A{j}" for j in range(5, 40)]:
                    cell = sheet[k]

                    cell.alignment = Alignment(horizontal="center")

                for k in [f"C{j}" for j in range(5, 40)]:
                    cell = sheet[k]

                    if cell.value == "Billable Days":
                        global range_limit
                        range_limit = int(re.findall(r"\d+", cell.coordinate)[0])
                        break

                    cell.alignment = Alignment(horizontal="center")

                for k in [i + f"{j}" for i in ["B", "D"] for j in range(5, 40)]:
                    cell = sheet[k]

                    if cell.coordinate == f"D{range_limit}":
                        cell.font = Font(bold=True)

                    cell.alignment = Alignment(horizontal="center")

            else:
                wb_style.save(excel_file_path)

        return [200, "Report Generated Successfully.", user_data]

    except Exception as e:
        # Log the error
        print(f"An error occurred: {str(e)}")
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        print(exc_type, fname, exc_tb.tb_lineno)

        return [500, str(e), None]


def format_date(date_str):
    if isinstance(date_str, Timestamp):
        date_str = date_str.strftime("%Y-%m-%d")  # Convert Timestamp to string
    try:
        # Attempt to parse the date string with various formats
        date_obj = parse(date_str)
        formatted_date = date_obj.strftime("%d-%m-%Y")
        return formatted_date
    except (ValueError, TypeError):
        # If parsing fails or the input is not a string, return the original value
        return str(date_str)


# Preprocess the name and item['Name'] strings
def preprocess_name(input_str):
    # Split the string into words, remove spaces, convert to lowercase, and sort
    return "".join(sorted(input_str.replace(",", "").lower().split()))


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(595, 520)
        MainWindow.setFixedSize(595, 520)
        MainWindow.setWindowIcon(QIcon("icon.png"))

        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        # Create a button for the custom action
        self.custom_button = QPushButton("?", self.centralwidget)
        self.custom_button.setToolTip("About")
        self.custom_button.setGeometry(570, 10, 20, 20)

        font = QtGui.QFont()
        font.setFamily("Perpetua")
        font.setPointSize(12)
        font.setBold(True)

        self.groupBox = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.groupBox.setGeometry(QtCore.QRect(10, 120, 551, 271))
        font = QtGui.QFont()
        font.setBold(False)
        self.groupBox.setFont(font)
        self.groupBox.setStyleSheet("")
        self.groupBox.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.groupBox.setFlat(True)
        self.groupBox.setCheckable(False)
        self.groupBox.setObjectName("groupBox")
        #         self.groupBox.setStyleSheet("border-style: solid;\n"
        # "border-width: 1px;\n"
        # "border-color: rgb(17, 131, 112);\n"
        # "border-radius: 5px;")

        ################################### Output File Section #####################################################
        self.fileInputBox = QtWidgets.QGroupBox(parent=self.groupBox)
        self.fileInputBox.setGeometry(QtCore.QRect(10, 20, 541, 61))
        self.fileInputBox.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.fileInputBox.setObjectName("fileInputBox")
        font.setPointSize(10)

        self.inputFileText = QtWidgets.QPlainTextEdit(parent=self.fileInputBox)
        self.inputFileText.setEnabled(True)
        self.inputFileText.setGeometry(QtCore.QRect(10, 20, 421, 31))
        self.inputFileText.setReadOnly(True)
        self.inputFileText.setObjectName("inputFileText")
        self.inputFileText.setFont(font)

        self.uploadButton = QtWidgets.QPushButton(parent=self.fileInputBox)
        self.uploadButton.setGeometry(QtCore.QRect(440, 20, 91, 31))
        self.uploadButton.setToolTip("")
        icon = QtGui.QIcon.fromTheme("folder")
        self.uploadButton.setIcon(icon)
        self.uploadButton.setObjectName("uploadButton")
        ####################################################### END ############################################################

        ################################### Output File Section #####################################################
        self.outputFileBox = QtWidgets.QGroupBox(parent=self.groupBox)
        self.outputFileBox.setGeometry(QtCore.QRect(10, 160, 541, 61))
        self.outputFileBox.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.outputFileBox.setObjectName("outputFileBox")

        self.outputFileText = QtWidgets.QPlainTextEdit(parent=self.outputFileBox)
        self.outputFileText.setEnabled(True)
        self.outputFileText.setGeometry(QtCore.QRect(10, 20, 405, 31))
        self.outputFileText.setObjectName("outputFileText")

        self.generateButton = QtWidgets.QPushButton(parent=self.outputFileBox)
        self.generateButton.setGeometry(QtCore.QRect(440, 20, 91, 31))
        self.generateButton.setObjectName("generateButton")

        ####################################################### END ############################################################

        self.error_msg = QtWidgets.QLabel(parent=self.groupBox)
        self.error_msg.setGeometry(QtCore.QRect(20, 230, 521, 31))
        self.error_msg.setText("")
        self.error_msg.setObjectName("error_msg")
        self.error_msg.setStyleSheet("color:red;")
        self.error_msg.setFont(font)
        self.error_msg.setWordWrap(True)

        ################################### Selection of Year and Month box #####################################################
        self.year_month_box = QtWidgets.QGroupBox(parent=self.groupBox)
        self.year_month_box.setGeometry(QtCore.QRect(10, 90, 541, 71))
        self.year_month_box.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.year_month_box.setObjectName("year_month_box")

        self.monthBox = QtWidgets.QComboBox(parent=self.year_month_box)
        self.monthBox.setGeometry(QtCore.QRect(10, 20, 341, 40))
        self.monthBox.setEditable(True)
        self.monthBox.setObjectName("monthBox")
        months = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ]
        self.monthBox.addItems(months)
        # Set default month to current month
        currentMonthIndex = (
            QDate.currentDate().month() - 1
        )  # Month indices start from 0
        self.monthBox.setCurrentIndex(currentMonthIndex)

        self.yearBox = QtWidgets.QComboBox(parent=self.year_month_box)
        self.yearBox.setGeometry(QtCore.QRect(370, 20, 150, 40))
        self.yearBox.setEditable(True)
        self.yearBox.setObjectName("yearBox")
        years = [str(year) for year in range(2022, 2051)]  # Years from 2022 to 2050
        self.yearBox.addItems(years)
        # Set default year to current year
        currentYear = QDate.currentDate().year()
        yearIndex = self.yearBox.findText(str(currentYear))
        if yearIndex != -1:
            self.yearBox.setCurrentIndex(yearIndex)

        # Disable future months and years
        currentDate = QDate.currentDate()
        for i in range(12):  # 12 months
            if not (currentMonthIndex >= i):
                self.monthBox.model().item(i).setEnabled(False)

        for i in range(len(years)):
            if int(years[i]) > currentYear:
                self.yearBox.model().item(i).setEnabled(False)

        ####################################################### END ############################################################

        ##################################################### Category box #####################################################

        self.categoryBox = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.categoryBox.setGeometry(QtCore.QRect(20, 20, 541, 80))
        self.categoryBox.setStyleSheet(
            "border-style: solid;\n"
            "border-width: 1px;\n"
            "border-color: rgb(17, 131, 112);\n"
            "border-radius: 5px;"
        )
        self.categoryBox.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.categoryBox.setObjectName("categoryBox")

        self.categoryInput = QtWidgets.QPlainTextEdit(parent=self.categoryBox)
        self.categoryInput.setEnabled(True)
        self.categoryInput.setGeometry(QtCore.QRect(10, 30, 381, 31))
        self.categoryInput.setReadOnly(False)
        self.categoryInput.setObjectName("categoryInput")

        self.selectButton = QtWidgets.QPushButton(parent=self.categoryBox)
        self.selectButton.setGeometry(QtCore.QRect(400, 30, 130, 31))
        self.selectButton.setObjectName("selectButton")

        ####################################################### END ############################################################

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        self.generateButton.setStyleSheet(
            "background-color: #aae0a4; color: black; border-radius: 5px; border: 2px solid #aae0a4;"
        )
        self.uploadButton.setStyleSheet(
            "background-color: #ffe0a1; color: black; border-radius: 5px; border: 2px solid #ffe0a1;"
        )
        self.selectButton.setStyleSheet(
            "background-color: #a9d2d9; color: black; border-radius: 5px; border: 2px solid #a9d2d9;"
        )

        # Create a button for the custom action
        self.more_info_holiday = QPushButton("...", self.centralwidget)
        self.more_info_holiday.setToolTip("Holiday Excel Format")
        self.more_info_holiday.setGeometry(550, 390, 21, 22)

        self.holidayBox = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.holidayBox.setGeometry(QtCore.QRect(20, 410, 551, 80))
        self.holidayBox.setObjectName("holidayBox")

        self.holidayLabel = QtWidgets.QLabel(parent=self.holidayBox)
        self.holidayLabel.setGeometry(QtCore.QRect(10, 60, 421, 20))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(False)
        self.holidayLabel.setFont(font)
        self.holidayLabel.setStyleSheet("color:red;")
        self.holidayLabel.setObjectName("holidayLabel")

        self.plainTextEdit = QtWidgets.QPlainTextEdit(parent=self.holidayBox)
        self.plainTextEdit.setGeometry(QtCore.QRect(20, 30, 371, 31))
        self.plainTextEdit.setObjectName("plainTextEdit")
        self.plainTextEdit.setReadOnly(True)

        self.holidayListButton = QtWidgets.QPushButton(parent=self.holidayBox)
        self.holidayListButton.setGeometry(QtCore.QRect(400, 30, 141, 31))
        self.holidayListButton.setObjectName("holidayListButton")
        self.holidayListButton.setStyleSheet(
            "background-color: #ddabf7; color: black; border-radius: 5px; border: 2px solid #ddabf7;"
        )

        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Generate Report"))
        # self.label.setText(_translate("MainWindow", "Please enter raw attendance file to generate Attendance Billing Report"))
        self.groupBox.setTitle(
            _translate(
                "MainWindow",
                "Please enter raw attendance file to generate Attendance Billing Report",
            )
        )
        self.generateButton.setText(_translate("MainWindow", "Generate"))
        self.uploadButton.setText(_translate("MainWindow", "Upload"))
        self.outputFileBox.setTitle(_translate("MainWindow", "Enter Output File name"))
        self.year_month_box.setTitle(
            _translate("MainWindow", "Select Month and Year :")
        )
        self.outputFileText.setPlainText(
            _translate(
                "MainWindow",
                f"AWS Cloud Platform Engineering Services_Timesheet_{self.monthBox.currentText()} {self.yearBox.currentText()}",
            )
        )
        self.fileInputBox.setTitle(_translate("MainWindow", "File Input"))
        self.error_msg.setText(_translate("MainWindow", ""))

        self.categoryBox.setTitle(
            _translate(
                "MainWindow", "Upload a category file to classify the report(Optional)"
            )
        )
        self.selectButton.setText(_translate("MainWindow", "Select"))
        self.holidayBox.setTitle(
            _translate(
                "MainWindow", "Upload Holiday List for Client( **xlsx format only )"
            )
        )
        self.holidayLabel.setText(
            _translate("MainWindow", "** Currently Data is loaded for 2024")
        )
        self.holidayListButton.setText(_translate("MainWindow", "Holiday List"))


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Set up the user interface from Designer.
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.df = None
        # Initialize an empty dictionary to store team-wise users
        self.category = {}
        self.summary_tab = []
        self.HOLIDAY_LIST = None
        # Connect your buttons to functions
        self.ui.uploadButton.clicked.connect(self.uploadFile)
        self.ui.generateButton.clicked.connect(self.generateReport)
        self.ui.selectButton.clicked.connect(self.selectCategory)
        self.ui.custom_button.clicked.connect(self.show_custom_popup)
        # self.ui.outputFileText.textChanged.connect(self.onTextChanged)
        self.ui.monthBox.editTextChanged.connect(self.month_changed)
        self.ui.yearBox.editTextChanged.connect(self.year_changed)
        self.ui.holidayListButton.clicked.connect(self.load_holiday)
        self.ui.more_info_holiday.clicked.connect(self.show_holiday_format)

    def show_custom_popup(self):
        QMessageBox.information(
            self,
            "About",
            "This tool is proprietary to Hitachi Vantara Digital Solution.\n\n\n\t - Developed by Vimit.",
        )

    def show_holiday_format(self):
        table_content = """
                <html>
                    <head>
                        <style>
                            table {
                                font-family: arial, sans-serif;
                                border-collapse: collapse;
                                width: 100%;
                            }

                            td,
                            th {
                                border: 1px solid #dddddd;
                                text-align: left;
                                padding: 8px;
                            }

                            tr:nth-child(even) {
                                background-color: #dddddd;
                            }
                        </style>
                    </head>
                    <body>
                        <h2>Holiday List</h2>

                        <table>
                            <tr>
                                <th>&lt;Year&gt;</th>
                            </tr>
                            <tr>
                                <td>DD-MM-YYYY</td>
                            </tr>
                            <tr>
                                <td>DD-MM-YYYY</td>
                            </tr>
                            <tr>
                                <td>etc ...</td>
                            </tr>
                        </table>
                    </body>
                </html>

            """
        # Create a QMessageBox with HTML content
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Holiday List HTML Format")
        msg_box.setTextFormat(
            Qt.TextFormat.RichText
        )  # Set text format to RichText to support HTML
        msg_box.setText(table_content)
        msg_box.exec()

    def load_holiday(self):
        file_dialog = QFileDialog(self)
        filepath, _ = file_dialog.getOpenFileName(
            self, "Open Excel File", "", "Excel Files (*.xlsx *.xls, *.csv)"
        )

        if filepath:
            fileInfo = QtCore.QFileInfo(filepath)
            file_name = fileInfo.fileName()
            file_size = fileInfo.size()  # in bytes
            # Convert file size to kilobytes
            file_size_kb = file_size / 1024.0
            print(f"File Name: {file_name}, File Size: {file_size_kb:.2f} KB")
            self.holiday_df = read_file(filepath)

            try:
                self.HOLIDAY_LIST = [
                    format_date(date[2024]) for date in self.holiday_df
                ]
                self.ui.plainTextEdit.setPlainText(
                    f"{file_name} ({file_size_kb:.2f} KB)"
                )
                self.ui.plainTextEdit.setStyleSheet(
                    "border-style: solid;\nborder-width: 1px;\nborder-color: green;\nborder-radius: 5px;"
                )
            except Exception as e:
                self.HOLIDAY_LIST = None
                self.ui.plainTextEdit.setStyleSheet(
                    "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
                )

    def uploadFile(self):
        self.ui.error_msg.setText("")
        file_dialog = QFileDialog(self)
        filepath, _ = file_dialog.getOpenFileName(
            self, "Open Excel File", "", "Excel Files (*.xlsx *.xls, *.csv)"
        )

        if filepath:
            fileInfo = QtCore.QFileInfo(filepath)
            file_name = fileInfo.fileName()
            file_size = fileInfo.size()  # in bytes
            # Convert file size to kilobytes
            file_size_kb = file_size / 1024.0
            print(f"File Name: {file_name}, File Size: {file_size_kb:.2f} KB")

            # Create DataFrame with Pandas
            self.df = read_file(filepath)

            # # Update the first list of dictionaries
            # for item in self.df:
            #     rsname = item.get('Rsname')
            #     if rsname in name_to_id:
            #         item['5-2-1'] = name_to_id[rsname]
            #     else:
            #         item['5-2-1'] = None  # or you can set it to some default value

            # Adding Validation to file upload
            dict_value = dict(
                Counter(
                    list(
                        itertools.chain.from_iterable(
                            [
                                [item.split("-")[-1] for item in j]
                                for j in [list(i.keys())[4:-2] for i in self.df]
                            ]
                        )
                    )
                )
            )
            value = max(dict_value, key=dict_value.get)

            self.selected_month = self.ui.monthBox.currentText()

            if value == self.selected_month[:3]:
                self.ui.error_msg.setText("Valid Raw Excel Loaded")
                self.ui.error_msg.setStyleSheet("color:green;")
                # Update input text box with filename and size
                self.ui.inputFileText.setPlainText(
                    f"{file_name} ({file_size_kb:.2f} KB)"
                )
            else:
                self.ui.error_msg.setText(
                    "Invalid Raw excel, please check the file or selected month."
                )
                self.ui.error_msg.setStyleSheet("color:red;")
                self.ui.inputFileText.setPlainText("")
                self.df = None

    def clean_keys(self, dict_list):
        cleaned_list = []
        for data_dict in dict_list:
            cleaned_dict = {}
            for key, value in data_dict.items():
                # Clean the key by removing '\n' and extra spaces
                clean_key = key.replace("\n", " ").strip()
                cleaned_dict[clean_key] = value
            cleaned_list.append(cleaned_dict)
        return cleaned_list

    def onTextChanged(self):
        self.file_name = self.ui.outputFileText.toPlainText().strip()

        if " " in self.file_name:
            self.ui.outputFileText.setStyleSheet(
                "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
            )
        else:
            self.ui.outputFileText.setStyleSheet(
                "border-style: solid;\nborder-width: 1px;\nborder-color: green;\nborder-radius: 5px;"
            )

    def month_changed(self):
        self.ui.outputFileText.setPlainText(
            f"AWS Cloud Platform Engineering Services_Timesheet_{self.ui.monthBox.currentText()} {self.ui.yearBox.currentText()}"
        )

    def year_changed(self):
        currentYear = QDate.currentDate().year()

        if str(currentYear) > self.ui.yearBox.currentText():
            for i in range(12):  # 12 months
                self.ui.monthBox.model().item(i).setEnabled(True)
        else:
            currentMonthIndex = QDate.currentDate().month() - 1
            for i in range(12):  # 12 months
                if not (currentMonthIndex >= i):
                    self.ui.monthBox.model().item(i).setEnabled(False)
            else:
                self.ui.monthBox.setCurrentIndex(currentMonthIndex)
        self.ui.outputFileText.setPlainText(
            f"AWS Cloud Platform Engineering Services_Timesheet_{self.ui.monthBox.currentText()} {self.ui.yearBox.currentText()}"
        )

    def categorised_data(self, category, user_data):
        # Initialize an empty dictionary to store filtered data
        filtered_data_dict = {}

        # Iterate through each key-value pair in category
        for key, names_list in category.items():
            filtered_data = []
            total_hours = 0
            total_billable_days = 0
            total_service_credit_days = 0

            for name in names_list:
                # Preprocess the input name
                processed_name = preprocess_name(name)
                # Filter data based on the "Name" key in the data list
                # filtered = [item for item in user_data if item['Name'] == name]
                # Filter the user data based on processed names
                filtered = [
                    item
                    for item in user_data
                    if preprocess_name(item["Name"]) == processed_name
                ]
                filtered_data.extend(filtered)
                # Calculate totals
                for item in filtered:
                    total_hours += item["Billable Time (Hours)"]
                    total_billable_days += item["Total Number of Billable Days"]
                    total_service_credit_days += item["Service Credit Pool Days"]
            # Add the total entry to the filtered data
            total_entry = {
                "Name": "Total",
                "Billable Time (Hours)": total_hours,
                "Total Number of Billable Days": total_billable_days,
                "Service Credit Pool Days": total_service_credit_days,
            }
            filtered_data.append(total_entry)
            filtered_data_dict[key] = filtered_data

        return filtered_data_dict

    def add_summary_page(self):
        print(self.summary_tab)

        wb = load_workbook(self.file_name)
        sheet = wb.create_sheet("Summary", 0)

        # Set tab color for the sheet
        tab_color = "34b1eb"  # Hex color code (orange)
        sheet.sheet_properties.tabColor = tab_color

        # Write the header row starting from B4 and color the header cells
        header = list(self.summary_tab[0].keys())
        for col_index, value in enumerate(header):  # Start from column B (index 2)
            cell = sheet.cell(row=4, column=col_index + 1, value=value)
            # Apply font styling (bold) and fill color to the cell
            cell.font = Font(bold=True, size=10, color="f7fafa")

            cell.fill = PatternFill(
                start_color="4472C4", end_color="4472C4", fill_type="solid"
            )
            #:: TODO row of Total to color with -  #F2F2F2
            # Set column width based on header column
            if value in [
                "Role",
                "Total Available Billable Days",
                "Total Actual Billable Days (Including service credit)",
            ]:
                sheet.column_dimensions[cell.column_letter].width = 35
                cell.alignment = (
                    Alignment(wrap_text=True, horizontal="left", vertical="center")
                    if value == "Role"
                    else Alignment(
                        wrap_text=True, horizontal="center", vertical="center"
                    )
                )
            else:
                sheet.column_dimensions[cell.column_letter].width = 20
                cell.alignment = Alignment(
                    wrap_text=True, horizontal="center", vertical="center"
                )
            # Apply text wrapping and center align the text
            cell.border = Border(
                left=Side(style="thin"),
                right=Side(style="thin"),
                top=Side(style="thin"),
                bottom=Side(style="thin"),
            )

        try:
            row_start = 5
            for index, item in enumerate(self.summary_tab):
                col_index = 1
                for index_inner, (key, value) in enumerate(item.items()):
                    cell = sheet.cell(
                        row=row_start + index, column=col_index, value=value
                    )
                    cell.font = Font(size=10)
                    cell.alignment = (
                        Alignment(wrap_text=True, horizontal="left", vertical="center")
                        if col_index == 1
                        else Alignment(
                            wrap_text=True, horizontal="center", vertical="center"
                        )
                    )
                    cell.border = Border(
                        left=Side(style="thin"),
                        right=Side(style="thin"),
                        top=Side(style="thin"),
                        bottom=Side(style="thin"),
                    )
                    col_index += 1

        except Exception as e:
            print("Error ===>", str(e))

        wb.save(self.file_name)

    def add_category_data(self, user_data):
        global TOTAL_WORKING_DAY

        filtered_data_dict = self.categorised_data(self.category, user_data)

        wb = load_workbook(self.file_name)
        sheet = wb.create_sheet("AWS Cloud Platform Engineering", 0)

        # Set tab color for the sheet
        tab_color = "34b1eb"  # Hex color code (orange)
        sheet.sheet_properties.tabColor = tab_color

        # Write the header row starting from B4 and color the header cells
        header = list(user_data[0].keys())
        for col_index, value in enumerate(
            header, start=2
        ):  # Start from column B (index 2)
            cell = sheet.cell(row=4, column=col_index, value=value)
            # Apply font styling (bold) and fill color to the cell
            cell.font = Font(bold=True)

            cell.fill = PatternFill(
                start_color="B4C6E7", end_color="B4C6E7", fill_type="solid"
            )
            # Set column width based on header column
            if value == "Name":
                sheet.column_dimensions[cell.column_letter].width = 30
            else:
                sheet.column_dimensions[cell.column_letter].width = 15
                cell.alignment = Alignment(
                    wrap_text=True, horizontal="center", vertical="center"
                )
            # Apply text wrapping and center align the text
            cell.border = Border(
                left=Side(style="thin"),
                right=Side(style="thin"),
                top=Side(style="thin"),
                bottom=Side(style="thin"),
            )

        ######################################### ITERATION 1 ##########################################################
        # Merge cells B3 to E3 and add formatted text

        try:
            merge_counter = 3
            row_count = 5
            for index, (key, value) in enumerate(filtered_data_dict.items()):
                """
                merge_counter(3) + index(0) = 3+0 = 3
                merge_counter(3+15+1 = 19) + index(1) = 19 + 1 = 20
                merge_counter(19+3=22) + index(2) = 22 + 2= 24
                merge_counter(22+2) + index(3) = 24 + 3= 27

                row_count = 5(start), end = 19 , index = 0
                row_count = 19(start) + 2 = 21, end = 23
                row_count = 23(start) + 2 = 25, end = 26
                row_count = 26(start) + 2 = 28, end = 29
                """
                self.summary_tab.append(
                    {
                        "Role": key,
                        "No of Resource": len(value) - 1,
                        "APR'24 Working Days": TOTAL_WORKING_DAY,
                        "Total Available Billable Days": (len(value) - 1)
                        * (TOTAL_WORKING_DAY),
                        "Total Actual Billable Days (Including service credit)": value[
                            -1
                        ].get("Total Number of Billable Days") + value[-1].get(
                            "Service Credit Pool Days"
                        ),
                        "Service Credit Days": value[-1].get(
                            "Service Credit Pool Days"
                        ),
                        "Earn-Back Days": "",
                    }
                )
                merge_range = f"B{merge_counter + index}:E{merge_counter + index}"
                sheet.merge_cells(merge_range)
                merged_cell = sheet.cell(row=merge_counter + index, column=2, value=key)
                merged_cell.font = Font(bold=True)
                merged_cell.alignment = Alignment(
                    wrap_text=True, horizontal="center", vertical="center"
                )
                # merged_cell.fill = PatternFill(start_color="B4C6E7", end_color="B4C6E7", fill_type="solid")  # Orange color
                merged_cell.border = Border(
                    left=Side(style="thin"),
                    right=Side(style="thin"),
                    top=Side(style="thin"),
                    bottom=Side(style="thin"),
                )

                # Write data rows starting from B5
                for row_index, row_data in enumerate(
                    filtered_data_dict[key], start=row_count
                ):
                    for col_index, value in enumerate(
                        row_data.values(), start=2
                    ):  # Start from column B (index 2)
                        cell = sheet.cell(row=row_index, column=col_index, value=value)
                        # Apply text wrapping and center align the text
                        if col_index != 2:
                            cell.alignment = Alignment(
                                wrap_text=True, horizontal="center", vertical="center"
                            )
                        else:
                            # Add hyperlink to the corresponding sheet
                            # hyperlink_cell = sheet.cell(row=merge_counter + index, column=2)
                            if value != "Total":
                                cell.hyperlink = f"#{quote_sheetname(value)}!A1"
                                cell.font = Font(color="6a89bd")
                        # Apply border to the cell
                        cell.border = Border(
                            left=Side(style="thin"),
                            right=Side(style="thin"),
                            top=Side(style="thin"),
                            bottom=Side(style="thin"),
                        )

                        if row_data["Name"] == "Total":
                            cell.font = Font(bold=True)
                            cell.fill = PatternFill(
                                start_color="dcdfe0",
                                end_color="dcdfe0",
                                fill_type="solid",
                            )
                
                if index == 0:
                    merge_counter = merge_counter + len(filtered_data_dict[key]) + 1
                else:
                    merge_counter = merge_counter + len(filtered_data_dict[key])
                row_count = row_index + 2
            else:
                # Calculate totals
                total_no_of_resource = sum(
                    item["No of Resource"] for item in self.summary_tab
                )
                total_available_billable_days = sum(
                    item["Total Available Billable Days"] for item in self.summary_tab
                )
                total_actual_billable_days = sum(
                    item["Total Actual Billable Days (Including service credit)"]
                    for item in self.summary_tab
                )
                total_service_credit_days = sum(
                    item["Service Credit Days"] for item in self.summary_tab
                )

                # Add totals dictionary
                total_dict = {
                    "Role": "Total",
                    "No of Resource": total_no_of_resource,
                    "APR'24 Working Days": "",  # Typically, working days would not be summed.
                    "Total Available Billable Days": total_available_billable_days,
                    "Total Actual Billable Days (Including service credit)": total_actual_billable_days,
                    "Service Credit Days": total_service_credit_days,
                    "Earn-Back Days": total_actual_billable_days
                    - total_available_billable_days
                    - total_service_credit_days,
                }
                self.summary_tab.append(total_dict)

        except Exception as e:
            print("Error ===>", str(e))

        wb.save(self.file_name)

    def generateReport(self):
        self.ui.error_msg.setText("")
        # Implement report generation logic here
        self.selected_month = self.ui.monthBox.currentText()
        self.selected_year = self.ui.yearBox.currentText()

        self.file_name = self.ui.outputFileText.toPlainText().strip()
        # if " " in self.file_name:
        #     return
        # else:
        self.file_name = self.file_name + ".xlsx"

        if self.HOLIDAY_LIST:

            hl_count = Counter([i.split("-")[-1] for i in self.HOLIDAY_LIST])

            if len(hl_count) > 1:
                self.ui.plainTextEdit.setStyleSheet(
                    "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
                )
                return
            else:
                if dict(hl_count).get(self.selected_year):
                    self.ui.plainTextEdit.setStyleSheet(
                        "border-style: solid;\nborder-width: 1px;\nborder-color: green;\nborder-radius: 5px;"
                    )
                else:
                    self.ui.plainTextEdit.setStyleSheet(
                        "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
                    )
                    return
        else:
            self.ui.plainTextEdit.setStyleSheet("")

        if self.df:
            self.df = self.clean_keys(self.df)
            status, response, user_data = (
                generate_excel(
                    self.selected_month,
                    self.selected_year,
                    self.file_name,
                    self.df,
                    self.HOLIDAY_LIST,
                    self.name_mapping,
                )
                if self.HOLIDAY_LIST
                else generate_excel(
                    self.selected_month,
                    self.selected_year,
                    self.file_name,
                    self.df,
                    HOLIDAY_LIST_2024,
                    self.name_mapping,
                )
            )
            if status == 200:
                self.ui.error_msg.setText(response)
                self.ui.error_msg.setStyleSheet("color:green;")

                if self.category:
                    self.add_category_data(user_data)
                    self.add_summary_page()
            else:
                self.ui.error_msg.setText(response)
                self.ui.error_msg.setStyleSheet("color:red;")
        else:
            self.ui.error_msg.setText("Please provide raw excel file as an input.")

        print("Proccess Complete.")

    def selectCategory(self):
        file_dialog = QFileDialog(self)
        filepath, _ = file_dialog.getOpenFileName(
            self, "Open Excel File", "", "Excel Files (*.xlsx *.xls, *.csv)"
        )

        if filepath:
            fileInfo = QtCore.QFileInfo(filepath)
            file_name = fileInfo.fileName()
            file_size = fileInfo.size()  # in bytes
            # Convert file size to kilobytes
            file_size_kb = file_size / 1024.0
            print(f"File Name: {file_name}, File Size: {file_size_kb:.2f} KB")

            self.ui.categoryInput.setPlainText(f"{file_name} ({file_size_kb:.2f} KB)")

            sheet_name = "PublicCloudResourceList"
            # Read the Excel file into a DataFrame
            df = pd.read_excel(filepath, sheet_name=sheet_name)

            # Convert the DataFrame to a list of dictionaries
            self.raw_category_list = df.to_dict(orient="records")

            # Standardize the "Full Name" field by removing commas and spaces
            for item in self.raw_category_list:
                if "Full Name" in item:
                    item["Full Name"] = item["Full Name"].replace(",", "")

            # Iterate over each row in the DataFrame
            for _, row in df.iterrows():
                team = row["Team"]
                full_name = row["Full Name"].replace(",", "")

                # Check if the team is already in the dictionary
                if team in self.category:
                    self.category[team].append(full_name)
                else:
                    self.category[team] = [full_name]

            # Create a mapping from Full Name to 521 ID for quick lookup
            self.name_mapping = {
                preprocess_name(item["Full Name"]): [
                    item["521 ID"],
                    item["Point of Contact"],
                    item["Start Date"],
                    item["End Date"],
                ]
                for item in self.raw_category_list
            }


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())
