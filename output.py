# Form implementation generated from reading ui file 'Billing.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
import calendar
import itertools
import os
import re
import sys
import time
from collections import Counter
from copy import copy
import numpy as np
import openpyxl
import pandas as pd
import xlsxwriter
from dateutil.parser import parse
from openpyxl import load_workbook
from openpyxl.styles import Alignment, Border, Font, PatternFill, Side
from openpyxl.worksheet.merge import MergeCell, MergeCells
from pandas._libs.tslibs.timestamps import Timestamp
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import QDate, Qt
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import (
    QApplication,
    QFileDialog,
    QLabel,  # type: ignore
    QMainWindow,
    QMessageBox,
    QPushButton,
)
from openpyxl.utils import quote_sheetname
from openpyxl.utils import get_column_letter
from openpyxl import Workbook
from dateutil import parser
from datetime import datetime


HOLIDAY_LIST_2024 = [
    "01-01-2024",
    "15-01-2024",
    "26-01-2024",
    "25-03-2024",
    "29-03-2024",
    "09-04-2024",
    "11-04-2024",
    "01-05-2024",
    "13-05-2024",
    "15-08-2024",
    "02-10-2024",
    "31-10-2024",
    "25-12-2024",
]


TOTAL_WORKING_DAY = 0


def read_file(file_path):
    try:
        # Check file extension to determine how to read the file
        if file_path.endswith(".csv"):
            df = pd.read_csv(file_path)
        elif file_path.endswith(".xlsx"):
            df = pd.read_excel(file_path)
        else:
            raise ValueError(
                "Unsupported file format. Please provide a CSV or Excel file."
            )

        # Return the DataFrame if reading is successful
        return df.to_dict("records")

    except FileNotFoundError:
        print(f"Error: File not found at '{file_path}'")
    except Exception as e:
        print(f"Error reading file '{file_path}': {e}")

    # Return None if there is an error
    return None

def sort_list_of_dicts(data):
    # Separate the dict with 'Name' equal to 'Total'
    total_dict = [d for d in data if d.get('Name') == 'Total']
    
    # Sort the remaining dicts by 'Name'
    sorted_data = sorted([d for d in data if d.get('Name') != 'Total'], key=lambda x: x['Name'])
    
    # Append the 'Total' dict at the end
    if total_dict:
        sorted_data.extend(total_dict)
    
    return sorted_data

def get_month_details(month_name, year):
    # Get the month number from the month name
    month_number = list(calendar.month_name).index(month_name.capitalize())

    # Get the calendar for the specified month and year
    cal = calendar.monthcalendar(year, month_number)

    # Dictionary to map weekday number to weekday name
    weekdays = {
        0: "Monday",
        1: "Tuesday",
        2: "Wednesday",
        3: "Thursday",
        4: "Friday",
        5: "Saturday",
        6: "Sunday",
    }

    month_details = []

    # Iterate through each week in the month
    for week in cal:
        week_details = []
        # Iterate through each day in the week
        for day in week:
            # If the day is zero, it means it's part of the previous or next month
            if day == 0:
                week_details.append(None)
            else:
                # Get the day name using the weekdays dictionary
                day_name = weekdays[calendar.weekday(year, month_number, day)]
                # Check if it's a weekend (Saturday or Sunday)
                is_weekend = day_name in ["Saturday", "Sunday"]
                # Append the day details to the week_details list
                week_details.append(
                    {"day": day, "day_name": day_name, "is_weekend": is_weekend}
                )
        # Append the week_details list to the month_details list
        month_details.append(week_details)

    return month_details, month_number

def date_calculation(date):
    # Check if the date is already a datetime object
    if isinstance(date, datetime):
        date_obj = date
    else:
        # Parse the date string or timestamp
        date_obj = parser.parse(str(date))

    # Extract the day, month, and year
    day = date_obj.day
    month = date_obj.month
    year = date_obj.year

    return day, month, year
# add validation of month, like if use data is for april and month is may
# :: TODO calculation for individual user - billable days - fixed - done
# :: TODO exclude date cal for holiday days if user has marked the attendance - done
def generate_excel(
    month, year, output_file_name, selected_row, holiday_list, name_mapping, name_order_list, progress_bar
):
    global TOTAL_WORKING_DAY
    sheets_name = []
    try:
        user_data = list()
        non_complaince_user = []
        month_name = month
        holiday_list = holiday_list

        year = int(year)
        month_details, month_number = get_month_details(month_name, year)
        month_number = f"{month_number:02}" if month_number < 10 else month_number
        month_holiday_list = [
            x for x in holiday_list if re.findall(f"\d+-{month_number}-\d+", x)
        ]
        # print("month_holiday_list ===>", month_holiday_list)
        month_day_holiday_list = [k.split("-")[0] for k in month_holiday_list]
        # print("month_day_holiday_list ===>", month_day_holiday_list)
        df_sheets = dict()
        excel_file_path = output_file_name

        # Creating a mapping from Rsname to their positions in the custom order
        order_map = {preprocess_name(name): index for index, name in enumerate(name_order_list)}

        # Sorting the list of dictionaries by the custom order
        selected_row = sorted(selected_row, key=lambda x: order_map.get(preprocess_name(x["Rsname"]), float('inf')))
        
        attendance_len = len(selected_row)
        progress_step = 0
        step = 100/attendance_len
        for new_data in selected_row:
            start_date, end_date, sd, sm, sy, ed, em, ey, sm_flag, em_flag = (None, )* 10
            billable_days = 0
            weekends = 0
            total_working_days = 0
            data_model = []
            leave_taken = 0
            public_holiday = 0
            mismatch_date = []
            name = preprocess_name(new_data.get("Rsname"))
            start_date, end_date = name_mapping[name][2:] if  name_mapping.get(name) else (None, )*2

            if start_date:
                sd, sm, sy=date_calculation(start_date)

                sm = f"{sm:02}" if sm < 10 else sm

                sm_flag = sm == month_number
            
            if end_date:
                ed, em, ey = date_calculation(end_date)
                em = f"{em:02}" if em < 10 else em
                em_flag = em == month_number

            for week in month_details:
                for day in week:
                    if day:
                        date = day["day"]
                        is_weekend_or_leave = "Weekend" if day["is_weekend"] else ""
                        if day["is_weekend"]:
                            weekends += 1
                        else:
                            total_working_days += 1
                        dt = f"{date}-{month_name[:3]}"
                        day_name = f"{day['day_name']}"

                        key = (
                            f"{day_name[:3]}, {f'{date:02}' if date < 10 else date}-"
                            f"{month_name[:3].title()}"
                        )
                        # print("DAY ===>", f"{date:02}" if date < 10 else date)
                        # holiday_list = [j.split("-")[0] for j in holiday_list ]
                        calculated_date = f"{date:02}" if date < 10 else f"{date}"
                        if day["is_weekend"]:
                            dt_status = 0
                        else:
                            rounded_values = list(
                                np.around(np.arange(2.5, 4, 0.1), decimals=1)
                            )

                            match new_data.get(key):
                                case 8:
                                    dt_status = 1
                                    # As some user can mark attendace on holiday date
                                    if calculated_date in month_day_holiday_list:
                                        mismatch_date.append(calculated_date)
                                        public_holiday += 1
                                        dt_status = 0

                                        # for Holiday keyword to be added
                                        is_weekend_or_leave = "Holiday"
                                case 4:
                                    dt_status = 0.5
                                    leave_taken += 0.5
                                case value if value in rounded_values:
                                    dt_status = 0.25
                                    leave_taken += 0.25
                                case 0:
                                    if calculated_date in month_day_holiday_list:
                                        public_holiday += 1
                                        dt_status = 0

                                        # for Holiday keyword to be added
                                        is_weekend_or_leave = "Holiday"
                                    else:
                                        leave_taken += 1
                                        dt_status = 0

                                        # for leave keyword to be added
                                        is_weekend_or_leave = "Leave"
                                case _:
                                    leave_taken += 1
                                    dt_status = 0
                        billable_days += dt_status

                        """
                            (dt, day_name[:3], dt_status, is_weekend_or_leave, "", "", "", "")
                            ('1-Jun', 'Thu', 1, '', '', '', '', '')
                        """
                        if sm_flag and not em_flag:
                            if date < sd:
                                dt_status = 0
                                total_working_days -= 1
                                
                        
                        if em_flag and not sm_flag:
                            if date > ed:
                                dt_status = 0
                                total_working_days -= 1
                        
                        if em_flag and sm_flag:
                            if  date > ed or  date < sd:
                                dt_status = 0
                                total_working_days -= 1

                        data_model.append(
                            (
                                dt,
                                day_name[:3],
                                dt_status,
                                is_weekend_or_leave,
                                "",
                                "",
                                "",
                                "",
                            )
                        )

            billable_days = total_working_days - leave_taken
            # print("USER =====>", new_data.get("Rsname"))
            # print("BILLABLE ====>", billable_days)
            # print("WEEKENDS ====>", weekends)
            # print("TOTAL WORKING DAYS ====>", total_working_days)
            # print("LEAVE TAKEN ====>", leave_taken)
            # print("-"*20)
            # print("PUBLIC HOLIDAY ====>", public_holiday)
            point_of_contact = (
                name_mapping[name][1] if name_mapping.get(name) else "xxxxxxx"
            )
            ID_521 = name_mapping[name][0] if name_mapping.get(name) else "xxxxxxx"
            if mismatch_date:
                non_complaince_user.append(
                    {
                        "Name": new_data.get("Rsname"),
                        "Month": month,
                        "Listed Month Holiday": month_day_holiday_list,
                        "Attendance Marked on Holiday": mismatch_date,
                    }
                )
            data = {
                "Vendor Organization": ["Resource Name", "Month", "Date"],
                "Hitachi Vantara": [
                    f"{new_data.get('Rsname')}",
                    f"{month_name}",
                    "Day",
                ],
                "Point of Contact": ["5-2-1", "Working Days", "Working Status"],
                f"{point_of_contact}": [
                    f"{ID_521}",
                    f"{total_working_days}",
                    "Remarks",
                ],
                "Adjustments from Last Month": ["", "", ""],
                "0": ["", "", ""],
                "": ["", "", ""],
                "Week Off": ["Personal/Sick Leave", "", ""],
            }
            df = pd.DataFrame(data)

            # Create a new sheet or get the existing one
            sheet_name = new_data.get("Rsname")

            for i in data_model:
                df.loc[len(df)] = i

            df.loc[len(df)] = [
                "Leaves Taken",
                f"{leave_taken}",
                "Billable Days",
                f"{billable_days}",
                "",
                "",
                "",
                "",
            ]

            df.loc[len(df)] = ["Weekends", f"{weekends}", "", "", "", "", "", ""]
            df.loc[len(df)] = [
                "Public Holidays",
                f"{public_holiday}",
                "",
                "",
                "",
                "",
                "",
                "",
            ]

            # print(df)
            df_sheets.update({sheet_name: df})
            user_data.append(
                {
                    "Name": sheet_name,
                    #   "Total Billable Time": (total_working_days-leave_taken-public_holiday) * 8 ,
                    "Billable Time (Hours)": (total_working_days - leave_taken) * 8,
                    #    "Weekends": weekends, "Public Holidays": public_holiday,
                    "Total Number of Billable Days": total_working_days - leave_taken,
                    "Service Credit Pool Days": leave_taken,
                }
            )
            progress_step += int(step)
            progress_bar.setValue(progress_step)
        else:
            TOTAL_WORKING_DAY = total_working_days
            
            # Create a Pandas Excel writer using XlsxWriter as the engine
            with pd.ExcelWriter(excel_file_path, engine="xlsxwriter") as writer:

                for key, value in df_sheets.items():
                    # Write each dataframe to a different sheet
                    value.to_excel(writer, sheet_name=key, index=False)

                # Access the XlsxWriter workbook and worksheet objects
                workbook = writer.book
                worksheets = writer.sheets

                # Access each worksheet and modify the formatting if needed
                for sheet_name, worksheet in worksheets.items():
                    # Example: set column width of the first column to 20
                    worksheet.set_column(0, 0, 20)
                    worksheet.set_column(1, 1, 20)
                    worksheet.set_column(2, 2, 20)
                    worksheet.set_column(3, 3, 15)
                    worksheet.set_column(4, 4, 30)
                    worksheet.set_column(7, 7, 17)

                    sheets_name.append(sheet_name)

            wb_style = load_workbook(excel_file_path)
            border = Border(
                left=Side(border_style="thin"),
                right=Side(border_style="thin"),
                top=Side(border_style="thin"),
                bottom=Side(border_style="thin"),
            )
            for i in sheets_name:
                sheet = wb_style[i]

                for row in sheet.iter_rows():
                    for cell in row:
                        cell.border = border
                        if cell.value == "Weekend":
                            numbers = re.findall(r"\d+", cell.coordinate)[0]
                            cell_list = [
                                f"B{numbers}",
                                f"C{numbers}",
                                f"D{numbers}",
                            ]
                            for k in cell_list:
                                cell_bold = sheet[k]
                                cell_bold.fill = PatternFill(
                                    start_color="b6bbbf",
                                    end_color="b6bbbf",
                                    fill_type="solid",
                                )  # grey color
                        if cell.value == "Leave":
                            cell_bold = sheet[cell.coordinate]
                            cell_bold.fill = PatternFill(
                                start_color="fce1dc",
                                end_color="fce1dc",
                                fill_type="solid",
                            )  # red color

                        if cell.value == "Holiday":
                            cell_bold = sheet[cell.coordinate]
                            cell_bold.fill = PatternFill(
                                start_color="cffccf",
                                end_color="cffccf",
                                fill_type="solid",
                            )  # green color

                        if cell.value in [
                            "Leaves Taken",
                            "Weekends",
                            "Public Holidays",
                            "Billable Days",
                        ]:
                            cell_bold = sheet[cell.coordinate]
                            cell_bold.font = Font(bold=True, color="FFFFFF")
                            cell_bold.fill = PatternFill(
                                start_color="4d6c82",
                                end_color="4d6c82",
                                fill_type="solid",
                            )

                for j in ["B1", "D1", "H1", "F1"]:
                    cell_bold = sheet[j]
                    cell_bold.font = Font(bold=False)

                for j in [
                    "A1",
                    "C1",
                    "E1",
                    "A2",
                    "C2",
                    "A3",
                    "C3",
                    "A4",
                    "B4",
                    "C4",
                    "D4",
                    "G1",
                    "G2",
                ]:
                    cell_bold = sheet[j]
                    cell_bold.font = Font(bold=True)
                    if j == "G2":
                        cell_bold.fill = PatternFill(
                            start_color="fce1dc",
                            end_color="fce1dc",
                            fill_type="solid",
                        )  # red color
                    else:
                        cell_bold.fill = PatternFill(
                            start_color="b6bbbf",
                            end_color="b6bbbf",
                            fill_type="solid",
                        )  # grey color

                for j in ["A4", "B4", "C4", "D4", "E4", "F4"]:
                    cell_bold = sheet[j]
                    cell_bold.font = Font(bold=True, color="FFFFFF")
                    cell_bold.fill = PatternFill(
                        start_color="4d6c82", end_color="4d6c82", fill_type="solid"
                    )

                for k in [chr(i) + f"{j}" for i in range(65, 73) for j in range(1, 5)]:
                    cell = sheet[k]
                    cell.alignment = Alignment(horizontal="left")

                for k in [f"A{j}" for j in range(5, 40)]:
                    cell = sheet[k]

                    cell.alignment = Alignment(horizontal="center")

                for k in [f"C{j}" for j in range(5, 40)]:
                    cell = sheet[k]

                    if cell.value == "Billable Days":
                        global range_limit
                        range_limit = int(re.findall(r"\d+", cell.coordinate)[0])
                        break

                    cell.alignment = Alignment(horizontal="center")

                for k in [i + f"{j}" for i in ["B", "D"] for j in range(5, 40)]:
                    cell = sheet[k]

                    if cell.coordinate == f"D{range_limit}":
                        cell.font = Font(bold=True)

                    cell.alignment = Alignment(horizontal="center")

            else:
                wb_style.save(excel_file_path)

        return [200, "Report Generated Successfully.", user_data, non_complaince_user]

    except Exception as e:
        # Log the error
        print(f"An error occurred: {str(e)}")
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        print(exc_type, fname, exc_tb.tb_lineno)

        return [500, str(e), None, None]


def format_date(date_str):
    if isinstance(date_str, Timestamp):
        date_str = date_str.strftime("%Y-%m-%d")  # Convert Timestamp to string
    try:
        # Attempt to parse the date string with various formats
        date_obj = parse(date_str)
        formatted_date = date_obj.strftime("%d-%m-%Y")
        return formatted_date
    except (ValueError, TypeError):
        # If parsing fails or the input is not a string, return the original value
        return str(date_str)


# Preprocess the name and item['Name'] strings
def preprocess_name(input_str):
    # Split the string into words, remove spaces, convert to lowercase, and sort
    return "".join(sorted(input_str.replace(",", "").lower().split()))


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(595, 570)
        MainWindow.setFixedSize(595, 570)
        MainWindow.setWindowIcon(QIcon("icon.png"))

        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        # Create a button for the custom action
        self.custom_button = QPushButton("?", self.centralwidget)
        self.custom_button.setToolTip("About")
        self.custom_button.setGeometry(570, 10, 20, 20)

        font = QtGui.QFont()
        font.setFamily("Perpetua")
        font.setPointSize(12)
        font.setBold(True)

        self.groupBox = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.groupBox.setGeometry(QtCore.QRect(10, 120, 551, 271))
        font = QtGui.QFont()
        font.setBold(False)
        self.groupBox.setFont(font)
        self.groupBox.setStyleSheet("")
        self.groupBox.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.groupBox.setFlat(True)
        self.groupBox.setCheckable(False)
        self.groupBox.setObjectName("groupBox")
        #         self.groupBox.setStyleSheet("border-style: solid;\n"
        # "border-width: 1px;\n"
        # "border-color: rgb(17, 131, 112);\n"
        # "border-radius: 5px;")

        ################################### Output File Section #####################################################
        self.fileInputBox = QtWidgets.QGroupBox(parent=self.groupBox)
        self.fileInputBox.setGeometry(QtCore.QRect(10, 20, 541, 61))
        self.fileInputBox.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.fileInputBox.setObjectName("fileInputBox")
        font.setPointSize(10)

        self.inputFileText = QtWidgets.QPlainTextEdit(parent=self.fileInputBox)
        self.inputFileText.setEnabled(True)
        self.inputFileText.setGeometry(QtCore.QRect(10, 20, 421, 31))
        self.inputFileText.setReadOnly(True)
        self.inputFileText.setObjectName("inputFileText")
        self.inputFileText.setFont(font)

        self.uploadButton = QtWidgets.QPushButton(parent=self.fileInputBox)
        self.uploadButton.setGeometry(QtCore.QRect(440, 20, 91, 31))
        self.uploadButton.setToolTip("")
        icon = QtGui.QIcon.fromTheme("folder")
        self.uploadButton.setIcon(icon)
        self.uploadButton.setObjectName("uploadButton")
        ####################################################### END ############################################################

        ################################### Output File Section #####################################################
        self.outputFileBox = QtWidgets.QGroupBox(parent=self.groupBox)
        self.outputFileBox.setGeometry(QtCore.QRect(10, 160, 541, 61))
        self.outputFileBox.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.outputFileBox.setObjectName("outputFileBox")

        self.outputFileText = QtWidgets.QPlainTextEdit(parent=self.outputFileBox)
        self.outputFileText.setEnabled(True)
        self.outputFileText.setGeometry(QtCore.QRect(10, 20, 405, 31))
        self.outputFileText.setObjectName("outputFileText")

        self.generateButton = QtWidgets.QPushButton(parent=self.outputFileBox)
        self.generateButton.setGeometry(QtCore.QRect(440, 20, 91, 31))
        self.generateButton.setObjectName("generateButton")

        ####################################################### END ############################################################

        self.error_msg = QtWidgets.QLabel(parent=self.groupBox)
        self.error_msg.setGeometry(QtCore.QRect(20, 230, 521, 31))
        self.error_msg.setText("")
        self.error_msg.setObjectName("error_msg")
        self.error_msg.setStyleSheet("color:red;")
        self.error_msg.setFont(font)
        self.error_msg.setWordWrap(True)

        ################################### Selection of Year and Month box #####################################################
        self.year_month_box = QtWidgets.QGroupBox(parent=self.groupBox)
        self.year_month_box.setGeometry(QtCore.QRect(10, 90, 541, 71))
        self.year_month_box.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.year_month_box.setObjectName("year_month_box")

        self.monthBox = QtWidgets.QComboBox(parent=self.year_month_box)
        self.monthBox.setGeometry(QtCore.QRect(10, 20, 341, 40))
        self.monthBox.setEditable(True)
        self.monthBox.setObjectName("monthBox")
        months = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ]
        self.monthBox.addItems(months)
        # Set default month to current month
        currentMonthIndex = (
            QDate.currentDate().month() - 1
        )  # Month indices start from 0
        self.monthBox.setCurrentIndex(currentMonthIndex)

        self.yearBox = QtWidgets.QComboBox(parent=self.year_month_box)
        self.yearBox.setGeometry(QtCore.QRect(370, 20, 150, 40))
        self.yearBox.setEditable(True)
        self.yearBox.setObjectName("yearBox")
        years = [str(year) for year in range(2022, 2051)]  # Years from 2022 to 2050
        self.yearBox.addItems(years)
        # Set default year to current year
        currentYear = QDate.currentDate().year()
        yearIndex = self.yearBox.findText(str(currentYear))
        if yearIndex != -1:
            self.yearBox.setCurrentIndex(yearIndex)

        # Disable future months and years
        currentDate = QDate.currentDate()
        for i in range(12):  # 12 months
            if not (currentMonthIndex >= i):
                self.monthBox.model().item(i).setEnabled(False)

        for i in range(len(years)):
            if int(years[i]) > currentYear:
                self.yearBox.model().item(i).setEnabled(False)

        ####################################################### END ############################################################

        ##################################################### Category box #####################################################

        self.categoryBox = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.categoryBox.setGeometry(QtCore.QRect(20, 20, 541, 80))
        self.categoryBox.setStyleSheet(
            "border-style: solid;\n"
            "border-width: 1px;\n"
            "border-color: rgb(17, 131, 112);\n"
            "border-radius: 5px;"
        )
        self.categoryBox.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.categoryBox.setObjectName("categoryBox")

        self.categoryInput = QtWidgets.QPlainTextEdit(parent=self.categoryBox)
        self.categoryInput.setEnabled(True)
        self.categoryInput.setGeometry(QtCore.QRect(10, 30, 381, 31))
        self.categoryInput.setReadOnly(False)
        self.categoryInput.setObjectName("categoryInput")

        self.selectButton = QtWidgets.QPushButton(parent=self.categoryBox)
        self.selectButton.setGeometry(QtCore.QRect(400, 30, 130, 31))
        self.selectButton.setObjectName("selectButton")

        ####################################################### END ############################################################

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        self.generateButton.setStyleSheet(
            "background-color: #aae0a4; color: black; border-radius: 5px; border: 2px solid #aae0a4;"
        )
        self.uploadButton.setStyleSheet(
            "background-color: #ffe0a1; color: black; border-radius: 5px; border: 2px solid #ffe0a1;"
        )
        self.selectButton.setStyleSheet(
            "background-color: #a9d2d9; color: black; border-radius: 5px; border: 2px solid #a9d2d9;"
        )

        # Create a button for the custom action
        self.more_info_holiday = QPushButton("...", self.centralwidget)
        self.more_info_holiday.setToolTip("Holiday Excel Format")
        self.more_info_holiday.setGeometry(550, 390, 21, 22)

        self.holidayBox = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.holidayBox.setGeometry(QtCore.QRect(20, 410, 551, 80))
        self.holidayBox.setObjectName("holidayBox")

        self.holidayLabel = QtWidgets.QLabel(parent=self.holidayBox)
        self.holidayLabel.setGeometry(QtCore.QRect(10, 60, 421, 20))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(False)
        self.holidayLabel.setFont(font)
        self.holidayLabel.setStyleSheet("color:red;")
        self.holidayLabel.setObjectName("holidayLabel")

        self.plainTextEdit = QtWidgets.QPlainTextEdit(parent=self.holidayBox)
        self.plainTextEdit.setGeometry(QtCore.QRect(20, 30, 371, 31))
        self.plainTextEdit.setObjectName("plainTextEdit")
        self.plainTextEdit.setReadOnly(True)

        self.holidayListButton = QtWidgets.QPushButton(parent=self.holidayBox)
        self.holidayListButton.setGeometry(QtCore.QRect(400, 30, 141, 31))
        self.holidayListButton.setObjectName("holidayListButton")
        self.holidayListButton.setStyleSheet(
            "background-color: #ddabf7; color: black; border-radius: 5px; border: 2px solid #ddabf7;"
        )

        self.progressBar = QtWidgets.QProgressBar(parent=self.centralwidget)
        self.progressBar.setGeometry(QtCore.QRect(20, 510, 551, 23))
        self.progressBar.setProperty("value", 0)
        self.progressBar.setAlignment(QtCore.Qt.AlignmentFlag.AlignBottom|QtCore.Qt.AlignmentFlag.AlignHCenter)
        self.progressBar.setInvertedAppearance(False)
        self.progressBar.setTextDirection(QtWidgets.QProgressBar.Direction.TopToBottom)
        self.progressBar.setObjectName("progressBar")

        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Generate Report"))
        # self.label.setText(_translate("MainWindow", "Please enter raw attendance file to generate Attendance Billing Report"))
        self.groupBox.setTitle(
            _translate(
                "MainWindow",
                "Please enter raw attendance file to generate Attendance Billing Report",
            )
        )
        self.generateButton.setText(_translate("MainWindow", "Generate"))
        self.uploadButton.setText(_translate("MainWindow", "Upload"))
        self.outputFileBox.setTitle(_translate("MainWindow", "Enter Output File name"))
        self.year_month_box.setTitle(
            _translate("MainWindow", "Select Month and Year :")
        )
        self.outputFileText.setPlainText(
            _translate(
                "MainWindow",
                f"AWS Cloud Platform Engineering Services_Timesheet_{self.monthBox.currentText()} {self.yearBox.currentText()}",
            )
        )
        self.fileInputBox.setTitle(_translate("MainWindow", "File Input"))
        self.error_msg.setText(_translate("MainWindow", ""))

        self.categoryBox.setTitle(
            _translate(
                "MainWindow", "Upload a category file to classify the report(Optional)"
            )
        )
        self.selectButton.setText(_translate("MainWindow", "Select"))
        self.holidayBox.setTitle(
            _translate(
                "MainWindow", "Upload Holiday List for Client( **xlsx format only )"
            )
        )
        self.holidayLabel.setText(
            _translate("MainWindow", "** Currently Data is loaded for 2024")
        )
        self.holidayListButton.setText(_translate("MainWindow", "Holiday List"))
        self.progressBar.setFormat(_translate("MainWindow", "%p%"))



class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Set up the user interface from Designer.
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.df = None
        # Initialize an empty dictionary to store team-wise users
        self.category = {}
        self.summary_tab = []
        self.HOLIDAY_LIST = None
        # Connect your buttons to functions
        self.ui.uploadButton.clicked.connect(self.uploadFile)
        self.ui.generateButton.clicked.connect(self.generateReport)
        self.ui.selectButton.clicked.connect(self.selectCategory)
        self.ui.custom_button.clicked.connect(self.show_custom_popup)
        # self.ui.outputFileText.textChanged.connect(self.onTextChanged)
        self.ui.monthBox.editTextChanged.connect(self.month_changed)
        self.ui.yearBox.editTextChanged.connect(self.year_changed)
        self.ui.holidayListButton.clicked.connect(self.load_holiday)
        self.ui.more_info_holiday.clicked.connect(self.show_holiday_format)
        self.raw_category_list, self.name_order_list= ([], )* 2
        self.category, self.name_mapping = (dict(),) * 2

    def show_custom_popup(self, title=None, message=None):
        if not title:
            title = "About"
        
        if not message:
             message="This tool is proprietary to Hitachi Digital Solution.\n\n\n\t - Developed by Vimit."

        QMessageBox.information(
            self,
            title,
            message
        )

    def show_custom_message(self, title=None, message=None):
        if not title:
            title = "About"
        
        if not message:
             message="This tool is proprietary to Hitachi Digital Solution.\n\n\n\t - Developed by Vimit."

        QMessageBox.warning(
            self,
            title,
            message
        )


    def show_holiday_format(self):
        table_content = """
                <html>
                    <head>
                        <style>
                            table {
                                font-family: arial, sans-serif;
                                border-collapse: collapse;
                                width: 100%;
                            }

                            td,
                            th {
                                border: 1px solid #dddddd;
                                text-align: left;
                                padding: 8px;
                            }

                            tr:nth-child(even) {
                                background-color: #dddddd;
                            }
                        </style>
                    </head>
                    <body>
                        <h2>Holiday List</h2>

                        <table>
                            <tr>
                                <th>&lt;Year&gt;</th>
                            </tr>
                            <tr>
                                <td>DD-MM-YYYY</td>
                            </tr>
                            <tr>
                                <td>DD-MM-YYYY</td>
                            </tr>
                            <tr>
                                <td>etc ...</td>
                            </tr>
                        </table>
                    </body>
                </html>

            """
        # Create a QMessageBox with HTML content
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Holiday List HTML Format")
        msg_box.setTextFormat(
            Qt.TextFormat.RichText
        )  # Set text format to RichText to support HTML
        msg_box.setText(table_content)
        msg_box.exec()

    def load_holiday(self):
        file_dialog = QFileDialog(self)
        filepath, _ = file_dialog.getOpenFileName(
            self, "Open Excel File", "", "Excel Files (*.xlsx *.xls, *.csv)"
        )

        if filepath:
            fileInfo = QtCore.QFileInfo(filepath)
            file_name = fileInfo.fileName()
            file_size = fileInfo.size()  # in bytes
            # Convert file size to kilobytes
            file_size_kb = file_size / 1024.0
            print(f"File Name: {file_name}, File Size: {file_size_kb:.2f} KB")
            self.holiday_df = read_file(filepath)

            try:
                self.HOLIDAY_LIST = [
                    format_date(date[2024]) for date in self.holiday_df
                ]
                self.ui.plainTextEdit.setPlainText(
                    f"{file_name} ({file_size_kb:.2f} KB)"
                )
                self.ui.plainTextEdit.setStyleSheet(
                    "border-style: solid;\nborder-width: 1px;\nborder-color: green;\nborder-radius: 5px;"
                )
            except Exception as e:
                self.HOLIDAY_LIST = None
                self.ui.plainTextEdit.setStyleSheet(
                    "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
                )

    def uploadFile(self):
        self.ui.error_msg.setText("")
        file_dialog = QFileDialog(self)
        filepath, _ = file_dialog.getOpenFileName(
            self, "Open Excel File", "", "Excel Files (*.xlsx *.xls, *.csv)"
        )

        if filepath:
            fileInfo = QtCore.QFileInfo(filepath)
            file_name = fileInfo.fileName()
            file_size = fileInfo.size()  # in bytes
            # Convert file size to kilobytes
            file_size_kb = file_size / 1024.0
            print(f"File Name: {file_name}, File Size: {file_size_kb:.2f} KB")

            # Create DataFrame with Pandas
            self.df = read_file(filepath)

            # # Update the first list of dictionaries
            # for item in self.df:
            #     rsname = item.get('Rsname')
            #     if rsname in name_to_id:
            #         item['5-2-1'] = name_to_id[rsname]
            #     else:
            #         item['5-2-1'] = None  # or you can set it to some default value

            # Adding Validation to file upload
            try:
                dict_value = dict(
                    Counter(
                        list(
                            itertools.chain.from_iterable(
                                [
                                    [item.split("-")[-1] for item in j]
                                    for j in [list(i.keys())[4:-2] for i in self.df]
                                ]
                            )
                        )
                    )
                )
                value = max(dict_value, key=dict_value.get)

                self.selected_month = self.ui.monthBox.currentText()

                if value == self.selected_month[:3]:
                    self.ui.error_msg.setText("Valid Raw Excel Loaded")
                    self.ui.error_msg.setStyleSheet("color:green;")
                    # Update input text box with filename and size
                    self.ui.inputFileText.setPlainText(
                        f"{file_name} ({file_size_kb:.2f} KB)"
                    )
                else:
                    self.ui.error_msg.setText(
                        "Invalid Raw excel, please check the file or selected month."
                    )
                    self.ui.error_msg.setStyleSheet("color:red;")
                    self.ui.inputFileText.setPlainText("")
                    self.df = None
            except Exception as e:
                print(e)
                self.ui.error_msg.setText(
                        "Invalid Raw excel, please check the file."
                    )
                self.ui.error_msg.setStyleSheet("color:red;")
                self.ui.inputFileText.setPlainText("")
                self.df = None


    def clean_keys(self, dict_list):
        cleaned_list = []
        for data_dict in dict_list:
            cleaned_dict = {}
            for key, value in data_dict.items():
                # Clean the key by removing '\n' and extra spaces
                clean_key = key.replace("\n", " ").strip()
                cleaned_dict[clean_key] = value
            cleaned_list.append(cleaned_dict)
        return cleaned_list

    def onTextChanged(self):
        self.file_name = self.ui.outputFileText.toPlainText().strip()

        if " " in self.file_name:
            self.ui.outputFileText.setStyleSheet(
                "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
            )
        else:
            self.ui.outputFileText.setStyleSheet(
                "border-style: solid;\nborder-width: 1px;\nborder-color: green;\nborder-radius: 5px;"
            )

    def month_changed(self):
        self.ui.outputFileText.setPlainText(
            f"AWS Cloud Platform Engineering Services_Timesheet_{self.ui.monthBox.currentText()} {self.ui.yearBox.currentText()}"
        )

    def year_changed(self):
        currentYear = QDate.currentDate().year()

        if str(currentYear) > self.ui.yearBox.currentText():
            for i in range(12):  # 12 months
                self.ui.monthBox.model().item(i).setEnabled(True)
        else:
            currentMonthIndex = QDate.currentDate().month() - 1
            for i in range(12):  # 12 months
                if not (currentMonthIndex >= i):
                    self.ui.monthBox.model().item(i).setEnabled(False)
            else:
                self.ui.monthBox.setCurrentIndex(currentMonthIndex)
        self.ui.outputFileText.setPlainText(
            f"AWS Cloud Platform Engineering Services_Timesheet_{self.ui.monthBox.currentText()} {self.ui.yearBox.currentText()}"
        )

    def categorised_data(self, category, user_data):
        # Initialize an empty dictionary to store filtered data
        filtered_data_dict = {}

        # Iterate through each key-value pair in category
        for key, names_list in category.items():
            filtered_data = []
            total_hours = 0
            total_billable_days = 0
            total_service_credit_days = 0

            for name in names_list:
                # Preprocess the input name
                processed_name = preprocess_name(name)
                # Filter data based on the "Name" key in the data list
                # filtered = [item for item in user_data if item['Name'] == name]
                # Filter the user data based on processed names
                filtered = [
                    item
                    for item in user_data
                    if preprocess_name(item["Name"]) == processed_name
                ]
                filtered_data.extend(filtered)
                # Calculate totals
                for item in filtered:
                    total_hours += item["Billable Time (Hours)"]
                    total_billable_days += item["Total Number of Billable Days"]
                    total_service_credit_days += item["Service Credit Pool Days"]
            # Add the total entry to the filtered data
            total_entry = {
                "Name": "Total",
                "Billable Time (Hours)": total_hours,
                "Total Number of Billable Days": total_billable_days,
                "Service Credit Pool Days": total_service_credit_days,
            }
            filtered_data.append(total_entry)
            filtered_data_dict[key] = filtered_data

        return filtered_data_dict

    def add_summary_page(self):

        wb = load_workbook(self.file_name)
        sheet = wb.create_sheet("Summary", 0)

        # Set tab color for the sheet
        tab_color = "34b1eb"  # Hex color code (orange)
        sheet.sheet_properties.tabColor = tab_color

        total_no_of_resource = sum(
                    item["No of Resource"] for item in self.summary_tab
        )
        total_available_billable_days = sum(
            item["Total Available Billable Days"] for item in self.summary_tab
        )
        total_actual_billable_days = sum(
            item["Total Actual Billable Days (Including Buffer Resources)"]
            for item in self.summary_tab
        )
        total_service_credit_days = sum(
            item["Service Credit Days"] for item in self.summary_tab
        )
        print("SELECTE MONTH ==>", self.selected_month[:3])
        # Add totals dictionary
        total_dict = {
            "Role": "Total",
            "No of Resource": total_no_of_resource,
            f"{self.selected_month[:3].upper()}'24 Working Days": "",  # Typically, working days would not be summed.
            "Total Available Billable Days": total_available_billable_days,
            "Total Actual Billable Days (Including Buffer Resources)": total_actual_billable_days,
            "Service Credit Days": total_service_credit_days,
            "Earn-Back Days": total_available_billable_days
            - total_actual_billable_days,
        }
        self.summary_tab.append(total_dict)

        # Write the header row starting from B4 and color the header cells
        header = list(self.summary_tab[0].keys())
        for col_index, value in enumerate(header):  # Start from column B (index 2)
            cell = sheet.cell(row=4, column=col_index + 1, value=value)
            # Apply font styling (bold) and fill color to the cell
            cell.font = Font(bold=True, size=10, color="f7fafa")

            cell.fill = PatternFill(
                start_color="4472C4", end_color="4472C4", fill_type="solid"
            )
            #:: TODO row of Total to color with -  #F2F2F2
            # Set column width based on header column
            if value in ["Role"]:
                sheet.column_dimensions[cell.column_letter].width = 35
                cell.alignment = (
                    Alignment(wrap_text=True, horizontal="left", vertical="center")
                    if value == "Role"
                    else Alignment(
                        wrap_text=True, horizontal="center", vertical="center"
                    )
                )
            elif value in ["Total Actual Billable Days (Including Buffer Resources)"]:
                sheet.column_dimensions[cell.column_letter].width = 40
                cell.alignment = (
                    Alignment(wrap_text=True, horizontal="left", vertical="center")
                    if value == "Role"
                    else Alignment(
                        wrap_text=True, horizontal="center", vertical="center"
                    )
                )
            elif value in ['No of Resource','Service Credit Days','Earn-Back Days']:
                sheet.column_dimensions[cell.column_letter].width = 15
                cell.alignment = Alignment(
                    wrap_text=True, horizontal="center", vertical="center"
                )
            else:
                sheet.column_dimensions[cell.column_letter].width = 20
                cell.alignment = Alignment(
                    wrap_text=True, horizontal="center", vertical="center"
                )
                
            # Apply text wrapping and center align the text
            cell.border = Border(
                left=Side(style="thin"),
                right=Side(style="thin"),
                top=Side(style="thin"),
                bottom=Side(style="thin"),
            )

        try:
            row_start = 5
            for index, item in enumerate(self.summary_tab):
                col_index = 1
                flag = None
                for index_inner, (key, value) in enumerate(item.items()):

                    cell = sheet.cell(
                        row=row_start + index, column=col_index, value=value
                    )
                    cell.font = Font(size=10)
                    cell.alignment = (
                        Alignment(wrap_text=True, horizontal="left", vertical="center")
                        if col_index == 1
                        else Alignment(
                            wrap_text=True, horizontal="center", vertical="center"
                        )
                    )
                    cell.border = Border(
                        left=Side(style="thin"),
                        right=Side(style="thin"),
                        top=Side(style="thin"),
                        bottom=Side(style="thin"),
                    )
                    col_index += 1

                    if value == "Total":
                        flag = index
                        cell.font = Font(bold=True)
                        cell.fill = PatternFill(
                            start_color="dcdfe0",
                            end_color="dcdfe0",
                            fill_type="solid",
                        )
                    
                    if flag == index:
                        cell.font = Font(bold=True)
                        cell.fill = PatternFill(
                            start_color="dcdfe0",
                            end_color="dcdfe0",
                            fill_type="solid",
                        )

        except Exception as e:
            print("Error ===>", str(e))

        wb.save(self.file_name)

    def shorten_sheet_name(self, name, max_length=31):
        if len(name) <= max_length:
            return name
        # Generate a unique short name
        return name[:max_length-3] + "..."

    def add_category_data(self, user_data):
        global TOTAL_WORKING_DAY

        filtered_data_dict = self.categorised_data(self.category, user_data)

        wb = load_workbook(self.file_name)
        sheet_index = 0
        for index, (key, values) in enumerate(filtered_data_dict.items()):

            # Calculate totals
            total_no_of_resource = len(values) - 1
            total_available_billable_days = (len(values) - 1)* (TOTAL_WORKING_DAY)
            
            #modifcation after feedback 
            # total_actual_billable_days = values[-1].get("Total Number of Billable Days") + values[-1].get("Service Credit Pool Days")
            total_actual_billable_days = values[-1].get("Total Number of Billable Days") - values[-1].get("Service Credit Pool Days")

            total_service_credit_days = values[-1].get("Service Credit Pool Days")

            total_dict = {
                "Role": key,
                "No of Resource": total_no_of_resource,
                f"{self.selected_month[:3].upper()}'24 Working Days": TOTAL_WORKING_DAY,  # Typically, working days would not be summed.
                "Total Available Billable Days": total_available_billable_days,
                "Total Actual Billable Days (Including Buffer Resources)": total_actual_billable_days,
                "Service Credit Days": total_service_credit_days,
                "Earn-Back Days":""
            }
            self.summary_tab.append(total_dict)
            sheet = wb.create_sheet(self.shorten_sheet_name(key), sheet_index)

            # Set tab color for the sheet
            tab_color = "34b1eb"  # Hex color code (orange)
            sheet.sheet_properties.tabColor = tab_color

            # Write the header row starting from B4 and color the header cells
            header = list(user_data[0].keys())
            for col_index, header_value in enumerate(header, start=2):  # Start from column B (index 2)
                cell = sheet.cell(row=4, column=col_index, value=header_value)
                # Apply font styling (bold) and fill color to the cell
                cell.font = Font(bold=True)

                cell.fill = PatternFill(
                    start_color="B4C6E7", end_color="B4C6E7", fill_type="solid"
                )
                # Set column width based on header column
                if header_value == "Name":
                    sheet.column_dimensions[cell.column_letter].width = 30
                else:
                    sheet.column_dimensions[cell.column_letter].width = 15
                    cell.alignment = Alignment(
                        wrap_text=True, horizontal="center", vertical="center"
                    )
                # Apply text wrapping and center align the text
                cell.border = Border(
                    left=Side(style="thin"),
                    right=Side(style="thin"),
                    top=Side(style="thin"),
                    bottom=Side(style="thin"),
                )

            ######################################### ITERATION 1 ##########################################################
            # Merge cells B3 to E3 and add formatted text

            try:
                merge_counter = 3
                row_count = 5
                
                
                
                merge_range = f"B{merge_counter}:E{merge_counter}"
                sheet.merge_cells(merge_range)
                merged_cell = sheet.cell(row=merge_counter, column=2, value=key)
                merged_cell.font = Font(bold=True)
                merged_cell.alignment = Alignment(
                    wrap_text=True, horizontal="center", vertical="center"
                )
                merged_cell.border = Border(
                    left=Side(style="thin"),
                    right=Side(style="thin"),
                    top=Side(style="thin"),
                    bottom=Side(style="thin"),
                )
                flag = None
                for row_index, value in enumerate(values, start=row_count):  # Start from column B (index 2)
                    for col_index, (key_item, item_value) in enumerate(value.items(), start=2):
                            cell = sheet.cell(row=row_index, column=col_index, value=item_value)
                            # Apply text wrapping and center align the text
                            if col_index != 2:
                                cell.alignment = Alignment(
                                    wrap_text=True, horizontal="center", vertical="center"
                                )
                            else:
                                # Add hyperlink to the corresponding sheet
                                # hyperlink_cell = sheet.cell(row=merge_counter + index, column=2)
                                if item_value != "Total":
                                    cell.hyperlink = f"#{quote_sheetname(item_value)}!A1"
                                    cell.font = Font(color="6a89bd")
                            # Apply border to the cell
                            cell.border = Border(
                                left=Side(style="thin"),
                                right=Side(style="thin"),
                                top=Side(style="thin"),
                                bottom=Side(style="thin"),
                            )

                            if value[key_item] == "Total":
                                flag = row_index
                                cell.font = Font(bold=True)
                                cell.fill = PatternFill(
                                    start_color="dcdfe0",
                                    end_color="dcdfe0",
                                    fill_type="solid",
                                )
                            
                            if flag == row_index:
                                cell.font = Font(bold=True)
                                cell.fill = PatternFill(
                                    start_color="dcdfe0",
                                    end_color="dcdfe0",
                                    fill_type="solid",
                                )
                
                sheet_index = sheet_index + len(values)
                

            except Exception as e:
                print("Error ===>", str(e))

        wb.save(self.file_name)

    def non_compliance_resources(self, data, filename="non_complaint_user.xlsx"):

        # Create a new workbook and select the active worksheet
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Attendance Data"
        
        # Define the header names and order
        headers = ["Name", "Month", "Listed Month Holiday", "Attendance Marked on Holiday"]
        
        # Set header style
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
        
        # Write the headers to the worksheet
        for col_num, header in enumerate(headers, start=1):
            cell = ws.cell(row=1, column=col_num, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = Alignment(horizontal="center", vertical="center")
            
            # Set column width
            column_width = max(len(header), 20)
            ws.column_dimensions[get_column_letter(col_num)].width = column_width
        
        # Write the data to the worksheet
        for row_num, entry in enumerate(data, start=2):
            ws.cell(row=row_num, column=1, value=entry["Name"])
            ws.cell(row=row_num, column=2, value=entry["Month"])
            ws.cell(row=row_num, column=3, value=", ".join(entry["Listed Month Holiday"]))
            ws.cell(row=row_num, column=4, value=", ".join(entry["Attendance Marked on Holiday"]))
            
            # Set alignment for data cells
            for col_num in range(1, 5):
                cell = ws.cell(row=row_num, column=col_num)
                cell.alignment = Alignment(horizontal="center", vertical="center")
        
        # Save the workbook to the specified filename
        wb.save(filename)
        print(f"Data written to {filename} with formatting.")

    def rearrange_sheets_in_same_workbook(self, file, sheet_order):
        # Load the source workbook
        wb = openpyxl.load_workbook(file)
        
        # Create a new workbook to temporarily hold the reordered sheets
        temp_wb = Workbook()
        
        # Remove the default sheet created by openpyxl
        temp_wb.remove(temp_wb.active)
        
        # Copy sheets from the source workbook to the temporary workbook in the specified order
        for sheet_name in sheet_order:
            if sheet_name in wb.sheetnames:
                source_sheet = wb[sheet_name]
                temp_sheet = temp_wb.create_sheet(title=sheet_name)
                
                
                # Copy column widths and add width of 20 to columns B, C, D
                for col_idx, col in enumerate(source_sheet.columns, 1):
                    col_letter = get_column_letter(col_idx)
                    if col_letter in ['B', 'C', 'D'] and sheet_name not in ['Summary', 'AWS Cloud Platform Engineering']:
                        temp_sheet.column_dimensions[col_letter].width = 20
                    elif col_letter in source_sheet.column_dimensions:
                        temp_sheet.column_dimensions[col_letter].width = source_sheet.column_dimensions[col_letter].width
                
                # Copy row heights
                for row in source_sheet.row_dimensions:
                    temp_sheet.row_dimensions[row].height = source_sheet.row_dimensions[row].height

                # Copy merged cells
                for merged_cell in source_sheet.merged_cells.ranges:
                    temp_sheet.merge_cells(str(merged_cell))

                # Copy all cells, values, and styles
                for row in source_sheet.iter_rows():
                    for cell in row:
                        temp_cell = temp_sheet.cell(row=cell.row, column=cell.column, value=cell.value)
                        
                        # Copy cell styles
                        if cell.has_style:
                            temp_cell.font = copy(cell.font)
                            temp_cell.border = copy(cell.border)
                            temp_cell.fill = copy(cell.fill)
                            temp_cell.number_format = copy(cell.number_format)
                            temp_cell.protection = copy(cell.protection)
                            temp_cell.alignment = copy(cell.alignment)
        
        # Save the temporary workbook to the original file
        temp_wb.save(file)
        print(f"Sheets rearranged and saved in user-defined order in {file}")
    
    def get_sheet_info(self, file):
        # Load the workbook
        wb = openpyxl.load_workbook(file)

        # Get the list of sheet names
        sheet_names = wb.sheetnames

        # Get the total number of sheets
        total_sheets = len(sheet_names)

        # Print the total number of sheets and their names in order
        print(f"Total number of sheets: {total_sheets}")
        print("Sheets in order:")
        for idx, sheet_name in enumerate(sheet_names):
            print(f"{idx + 1}. {sheet_name}")
    
    def generateReport(self):

        if not self.raw_category_list or not self.category or not self.name_mapping or not self.name_order_list:
            title = "Error"
            message = "Please select proper category file."
            self.show_custom_message(title=title, message=message)
            return None

        self.ui.error_msg.setText("")
        # Implement report generation logic here
        self.selected_month = self.ui.monthBox.currentText()
        self.selected_year = self.ui.yearBox.currentText()

        self.file_name = self.ui.outputFileText.toPlainText().strip()

        self.file_name = self.file_name + ".xlsx"

        if self.HOLIDAY_LIST:

            hl_count = Counter([i.split("-")[-1] for i in self.HOLIDAY_LIST])

            if len(hl_count) > 1:
                self.ui.plainTextEdit.setStyleSheet(
                    "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
                )
                return
            else:
                if dict(hl_count).get(self.selected_year):
                    self.ui.plainTextEdit.setStyleSheet(
                        "border-style: solid;\nborder-width: 1px;\nborder-color: green;\nborder-radius: 5px;"
                    )
                else:
                    self.ui.plainTextEdit.setStyleSheet(
                        "border-style: solid;\nborder-width: 1px;\nborder-color: red;\nborder-radius: 5px;"
                    )
                    return
        else:
            self.ui.plainTextEdit.setStyleSheet("")

        if self.df:
            self.df = self.clean_keys(self.df)
            # self.ui.progressBar.setValue(50)
            status, response, user_data, non_complaince_resources = (
                generate_excel(
                    self.selected_month,
                    self.selected_year,
                    self.file_name,
                    self.df,
                    self.HOLIDAY_LIST,
                    self.name_mapping,
                    self.name_order_list,
                    self.ui.progressBar
                )
                if self.HOLIDAY_LIST
                else generate_excel(
                    self.selected_month,
                    self.selected_year,
                    self.file_name,
                    self.df,
                    HOLIDAY_LIST_2024,
                    self.name_mapping,
                    self.name_order_list,
                    self.ui.progressBar
                )
            )
            if status == 200:
                self.ui.error_msg.setText(response)
                self.ui.error_msg.setStyleSheet("color:green;")
                remaining_val = 100 - self.ui.progressBar.value()

                step = remaining_val/3
                if self.category:
                    
                    self.add_category_data(user_data)
                    self.ui.progressBar.setValue(self.ui.progressBar.value()+int(step))
                    self.add_summary_page()
                    self.ui.progressBar.setValue(self.ui.progressBar.value()+int(step))
            else:
                self.ui.error_msg.setText(response)
                self.ui.error_msg.setStyleSheet("color:red;")

            if non_complaince_resources:
                self.non_compliance_resources(non_complaince_resources)

            # sys.exit(1)
            self.ui.progressBar.setValue(100)
        else:
            self.ui.error_msg.setText("Please provide raw excel file as an input.")
        # self.ui.progressBar.setValue(100)
        # print("Proccess Complete.")

    def selectCategory(self):
        file_dialog = QFileDialog(self)
        filepath, _ = file_dialog.getOpenFileName(
            self, "Open Excel File", "", "Excel Files (*.xlsx *.xls, *.csv)"
        )

        self.raw_category_list, self.name_order_list= ([], )* 2
        self.category, self.name_mapping = (dict(),) * 2

        try:
            if filepath:
                fileInfo = QtCore.QFileInfo(filepath)
                file_name = fileInfo.fileName()
                file_size = fileInfo.size()  # in bytes
                # Convert file size to kilobytes
                file_size_kb = file_size / 1024.0
                print(f"File Name: {file_name}, File Size: {file_size_kb:.2f} KB")

                self.ui.categoryInput.setPlainText(f"{file_name} ({file_size_kb:.2f} KB)")

                sheet_name = "PublicCloudResourceList"
                # Read the Excel file into a DataFrame
                df = pd.read_excel(filepath, sheet_name=sheet_name)
                df.replace({np.nan: None}, inplace = True)

                # Convert the DataFrame to a list of dictionaries
                self.raw_category_list = df.to_dict(orient="records")

                # Standardize the "Full Name" field by removing commas and spaces
                for item in self.raw_category_list:
                    if "Full Name" in item:
                        item["Full Name"] = item["Full Name"].replace(",", "")

                # Iterate over each row in the DataFrame
                for _, row in df.iterrows():
                    team = row["Team"]
                    full_name = row["Full Name"].replace(",", "")

                    # Check if the team is already in the dictionary
                    if team in self.category:
                        self.category[team].append(full_name)
                    else:
                        self.category[team] = [full_name]

                # Create a mapping from Full Name to 521 ID for quick lookup
                self.name_mapping = {
                    preprocess_name(item["Full Name"]): [
                        item["521 ID"],
                        item["Point of Contact"],
                        item["Start Date"],
                        item["End Date"],
                    ]
                    for item in self.raw_category_list
                }

                
                for k,v in self.category.items():
                    temp_list = sorted(v)
                    self.category[k] = temp_list
                    self.name_order_list.extend(temp_list)
                print("Category Created")
        except Exception as e:
            self.raw_category_list, self.name_order_list= ([], )* 2
            self.category, self.name_mapping = (dict(),) * 2


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())
